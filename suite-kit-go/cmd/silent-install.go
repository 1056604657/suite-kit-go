// all the variable used in this program is defined in vars.go
// if any question, please kindly contact Rocket team.
package cmd

import (
	"archive/tar"
	"archive/zip"
	"bufio"
	"bytes"
	"compress/gzip"
	_ "embed"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"os/user"
	"path/filepath"
	"strings"

	"github.com/cheggaaa/pb/v3"
	"github.com/spf13/cobra"
)

var SilentInstallCmd = &cobra.Command{
	Use:   "silent-install",
	Short: "Deploy itsma suite service",
	Long: `Deploy one or more itsma suite services on target environment.

Command example:
1. Deploy multi master env, and allow worker on master:
	suitectl silent-install --cdf-version 2021.02.0046 --artifactoryBase svsartifactory --smax-version 2021.02-b19 --major-version 2021.02 --virtual-fqdn "vfqdn.example.com" --masters "m1.example.com m2.example.com" --workers "w.example.com" --nfs-server "nfs.example.com" --master-as-worker

2. Deploy single master env with db ssl and vertica ssl, AIO:
	suitectl silent-install --db-ssl-cert "xxx" --vertica-ssl-cert "xxx" --masters "m.example.com" --workers "w1.example.com w2.example.com" --db-server "db.example.com" --vertica-server "vertica.example.com"  --smax-version 230813 --major-version 23.4 --cdf-version 23.4-144 --capabilities "X DND CGRO SAM SMPS" --nfs-server "nfs.example.com" --auto-approve
	`,
	Run: func(cmd *cobra.Command, _ []string) {
		if listResources {
			listEmbedResources()
		} else {
			call()
		}
	},
}

func ptr[T any](s T) *T {
	return &s
}

// This function appends a new string value to a slice, ensuring that the value is unique.
func uniqueAppend(slice []string, value string) []string {
	// Use a map to check if a value already exists
	exists := make(map[string]bool)
	result := []string{}

	// Add the current values from the slice to the map and result slice
	for _, v := range slice {
		exists[v] = true
		result = append(result, v)
	}

	// If the value is not in the map, add it to the result slice
	if !exists[value] {
		result = append(result, value)
	}

	return result
}

// unzipSkipFirstLayer extracts files and directories from a ZIP archive located at the `src` path,
// and saves them to the `dest` directory. During the extraction process, the top-level directory
// within the ZIP archive is skipped. This means that if the ZIP contains a structure like:
//
//	top-level-dir/
//	    file1.txt
//	    file2.txt
//
// After extraction, the `dest` directory will contain only:
//
//	file1.txt
//	file2.txt
//
// without the "top-level-dir" directory.
// generated by gpt4
func unzipSkipFirstLayer(src, dest string) error {
	r, err := zip.OpenReader(src)
	if err != nil {
		return err
	}
	defer r.Close()

	for _, f := range r.File {
		// skip the first layer
		parts := strings.SplitN(f.Name, "/", 2)
		if len(parts) < 2 {
			continue
		}
		newPath := filepath.Join(dest, parts[1])

		if f.FileInfo().IsDir() {
			os.MkdirAll(newPath, os.ModePerm)
			continue
		}

		rc, err := f.Open()
		if err != nil {
			return err
		}

		outFile, err := os.OpenFile(newPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
		if err != nil {
			rc.Close()
			return err
		}

		_, err = io.Copy(outFile, rc)
		outFile.Close()
		rc.Close()

		if err != nil {
			return err
		}
	}

	return nil
}

// Loads the featuresets JSON data from the given metadata.
func loadFeaturesetsJsonFromMetadata() {
	var buf bytes.Buffer
	file, err := os.Open(baseDir + "/metadata.tgz")
	if err != nil {
		log.Fatalf("[FATAL] Failed to open gzip file: %v", baseDir+"/metadata.tgz")
	}
	defer file.Close()

	gz, err := gzip.NewReader(file)
	if err != nil {
		log.Fatalf("[FATAL] Failed to create gzip reader: %v", err)
	}
	defer gz.Close()

	tr := tar.NewReader(gz)

	for {
		hdr, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("[FATAL] Error reading tar entry: %v", err)
		}

		if hdr.Typeflag == tar.TypeReg && strings.HasSuffix(hdr.Name, "/featuresets.json") {
			// if use buf := new(bytes.Buffer) buf would be a pointer.
			if _, err := io.Copy(&buf, tr); err != nil {
				log.Fatal("[FATAL] Failed to load featuresets.json.")
			}
			break
		}
	}

	err = json.Unmarshal(buf.Bytes(), &featuresetsJson)
	if err != nil {
		log.Fatalf("[FATAL] Failed to parse JSON: %v", err)
	}

	if buf.Bytes() == nil {
		log.Fatal("[FATAL] featuresets.json not found in the zip file")
	}
}

// Retrieves the current user's information.
func getCurrentUser() {
	u, err := user.Current()
	if err != nil {
		fmt.Println("Failed to get current user:", err)
		os.Exit(1)
	}

	if u.Uid != "0" {
		fmt.Println("This program must be run as root!")
		os.Exit(1)
	}
}

// Displays a confirmation message to the user and waits for their response.
func confirmMsg(msg string) {
	fmt.Print(msg, "(yes/no): ")
	reader := bufio.NewReader(os.Stdin)
	response, err := reader.ReadString('\n')
	if err != nil {
		log.Fatal("[FATAL] Error reading response:", err)
		os.Exit(1)
	}

	if response != "yes\n" {
		log.Fatal("[FATAL] Operation aborted by user.")
		os.Exit(1)
	}
}

// Creates an admin directory as a workspace.
func createAdminDir() {
	// Create /home/admin dir
	_, err := os.Stat(baseDir)

	if err == nil {
		if !approveAll {
			confirmMsg("Directory " + baseDir + " already exists. Do you want to remove and recreate it?")
		}

		err = os.RemoveAll(baseDir)
		if err != nil {
			log.Fatal("[FATAL] Error removing directory:", err)
			os.Exit(1)
		}
	} else if !os.IsNotExist(err) {
		log.Fatal("[FATAL] Error checking directory:", err)
		os.Exit(1)
	}
	err = os.MkdirAll(baseDir, 0777)
	if err != nil {
		log.Fatal("[FATAL] Error creating directory:", err)
		os.Exit(1)
	}
	log.Println("Directory " + baseDir + " created successfully.")
	// Finish creating /home/admin dir
}

// Downloads and unarchives the CDF package.
func downloadAndUnarchiveCdfPkg() {
	// Download cdf pkg according to the param.
	var downloadURL string
	dest := baseDir + "/cdf.zip"
	unarchiveDest := baseDir + "/ITOM_Platform_Foundation_Standard"
	versionParts := strings.Split(cdfVersion, "-")
	if len(versionParts) > 1 {
		downloadURL = fmt.Sprintf("https://%s.swinfra.net/artifactory/itom-buildoutput/cdf-daily-build/%s/OMT_Embedded_K8s_%s.zip", artifactoryBase, versionParts[0], cdfVersion)
	} else {
		downloadURL = fmt.Sprintf("https://%s.swinfra.net/artifactory/itom-buildoutput/cdf-daily-build/%s/ITOM_Platform_Foundation_Standard_%s.zip", artifactoryBase, strings.Join(strings.Split(cdfVersion, ".")[:2], "."), cdfVersion)
	}

	// Create the file
	out, err := os.Create(dest)
	if err != nil {
		log.Fatal("[FATAL] Error creating file:", err)
		return
	}
	defer out.Close()

	// Get the data
	log.Println("Start downloading CDF pkg", downloadURL)
	resp, err := http.Get(downloadURL)
	if err != nil {
		log.Fatal("[FATAL] Error fetching URL:", err)
		return
	}
	defer resp.Body.Close()

	// Check server response
	if resp.StatusCode != http.StatusOK {
		log.Fatalf("[FATAL] Server return non-200 status: %v", resp.Status)
		return
	}

	out, err = os.Create(dest)
	if err != nil {
		log.Fatal("[FATAL] Error creating file:", err)
		return
	}
	defer out.Close()

	// Create and start a new bar
	bar := pb.Full.Start64(resp.ContentLength)
	barReader := bar.NewProxyReader(resp.Body)

	_, err = io.Copy(out, barReader)
	if err != nil {
		log.Fatal("[FATAL] Error writing to file:", err)
		return
	}

	bar.Finish()
	log.Println("CDF pkg downloaded successfully and saved to", dest)

	// Unarchive cdf pkg
	err = unzipSkipFirstLayer(dest, unarchiveDest)
	if err != nil {
		log.Fatalf("[FATAL] Failed to unzip the file: %v", err)
		return
	}
	bar.Finish()
	log.Println("CDF pkg unarchived successfully to", unarchiveDest)
}

// Downloads the metadata for the application.
func downloadMetadata() {
	dest := baseDir + "/metadata.tgz"
	var downloadURL string
	var majorv string
	if majorVersion != "" {
		majorv = majorVersion
	} else {
		majorv = strings.Split(smaxVersion, "-")[0]
	}
	if strings.Contains(smaxVersion, "b") {
		downloadURL = fmt.Sprintf("https://%s.swinfra.net/artifactory/itom-buildoutput/itom-suite-metadata/ITSMA/%s/stable/itsma-suite-metadata-%s.tgz", artifactoryBase, majorv, smaxVersion)
	} else {
		downloadURL = fmt.Sprintf("https://%s.swinfra.net/artifactory/itom-buildoutput/itom-suite-metadata/ITSMA/%s/daily/itsma-suite-metadata-%s.tgz", artifactoryBase, majorv, smaxVersion)
	}

	// Create the file
	out, err := os.Create(dest)
	if err != nil {
		log.Fatal("[FATAL] Error creating file:", err)
		return
	}
	defer out.Close()

	// Get the data
	log.Println("Start downloading SMAX metadata", downloadURL)
	resp, err := http.Get(downloadURL)
	if err != nil {
		log.Fatal("[FATAL] Error fetching URL:", err)
		return
	}
	defer resp.Body.Close()

	// Check server response
	if resp.StatusCode != http.StatusOK {
		log.Fatalf("[FATAL] Server return non-200 status: %v", resp.Status)
		return
	}

	// Write the body to file
	_, err = io.Copy(out, resp.Body)
	if err != nil {
		log.Fatal("[FATAL] Error writing to file:", err)
		return
	}

	log.Println("SMAX metadata downloaded successfully and saved to", dest)
}

// Updates the installation properties based on the user's input.
func updateInstallProperties() {
	// Check if virtualFqdn is not empty and resolve its IP
	if virtualFqdn != "" {
		ips, err := net.LookupIP(virtualFqdn)
		if err == nil && len(ips) > 0 {
			// Append the IP address to installProperties
			installProperties += "\nHA_VIRTUAL_IP=" + ips[0].String()
		}
	}

	// Check if enableVxlan is true
	if enableVxlan {
		installProperties += "\nFLANNEL_BACKEND_TYPE=\"vxlan\""
	}

	// Write to file
	filePath := baseDir + "/ITOM_Platform_Foundation_Standard/install.properties"
	err := os.WriteFile(filePath, []byte(installProperties), 0644)
	if err != nil {
		log.Fatalf("[FATAL] Failed to write to %s: %v", filePath, err)
	}

	log.Println("Updated", filePath)
}

// Generates the SMAX configuration in JSON format.
func generateSmaxConfigJson() {
	err := json.Unmarshal([]byte(smaxJson), &smaxJsonOutput)
	if err != nil {
		log.Fatalf("[FATAL] Error parsing JSON: %v", err)
	}

	if masterAsWorker {
		smaxJsonOutput.AllowWorkerOnMaster = true
	}

	// update master info, current master wihich is executing this command would not be added in the list.
	for _, i := range strings.Fields(masters) {
		if i != currentMaster {
			var appendElement struct {
				Hostname          string `json:"hostname"`
				User              string `json:"user"`
				Password          string `json:"password"`
				SkipWarning       bool   `json:"skipWarning"`
				PrivateKey        string `json:"privateKey"`
				Type              string `json:"type"`
				ThinpoolDevice    string `json:"thinpoolDevice"`
				DeviceType        string `json:"deviceType"`
				FlannelIface      string `json:"flannelIface"`
				SkipResourceCheck bool   `json:"skipResourceCheck"`
			}
			appendElement.Hostname = i
			appendElement.User = "root"
			appendElement.Password = nodeRootPass
			appendElement.SkipWarning = true
			appendElement.PrivateKey = ""
			appendElement.Type = "default"
			appendElement.ThinpoolDevice = ""
			appendElement.DeviceType = "overlay2"
			appendElement.FlannelIface = ""
			appendElement.SkipResourceCheck = true
			smaxJsonOutput.MasterNodes = append(smaxJsonOutput.MasterNodes, appendElement)
		}
	}

	// update the workers info.
	for _, i := range strings.Fields(workers) {
		var appendElement struct {
			Hostname          string `json:"hostname"`
			User              string `json:"user"`
			Password          string `json:"password"`
			SkipWarning       bool   `json:"skipWarning"`
			PrivateKey        string `json:"privateKey"`
			Type              string `json:"type"`
			ThinpoolDevice    string `json:"thinpoolDevice"`
			DeviceType        string `json:"deviceType"`
			FlannelIface      string `json:"flannelIface"`
			SkipResourceCheck bool   `json:"skipResourceCheck"`
		}
		appendElement.Hostname = i
		appendElement.User = "root"
		appendElement.Password = nodeRootPass
		appendElement.SkipWarning = true
		appendElement.PrivateKey = ""
		appendElement.Type = "default"
		appendElement.ThinpoolDevice = ""
		appendElement.DeviceType = "overlay2"
		appendElement.FlannelIface = ""
		appendElement.SkipResourceCheck = true
		smaxJsonOutput.WorkerNodes = append(smaxJsonOutput.WorkerNodes, appendElement)
	}

	// update the external hostname, if virtualfqdn is setted, use virtualFqdn, or use master.
	if virtualFqdn != "" {
		smaxJsonOutput.Connection.ExternalHostname = strings.TrimSpace(virtualFqdn)
	} else {
		smaxJsonOutput.Connection.ExternalHostname = strings.TrimSpace(masters)
	}

	// update the nfs info, accroding to the nfsServer
	for i := range smaxJsonOutput.Volumes {
		smaxJsonOutput.Volumes[i].Host = strings.TrimSpace(nfsServer)
	}

	// update Database param, accroding to the internal db / external db.
	if strings.TrimSpace(dbServer) != "" {
		smaxJsonOutput.Database.Type = "extpostgres"
		smaxJsonOutput.Database.Param.DbHost = ptr(strings.TrimSpace(dbServer))
		smaxJsonOutput.Database.Param.DbPort = ptr("5432")
		smaxJsonOutput.Database.Param.DbName = ptr("cdfidmdb")
		smaxJsonOutput.Database.Param.DbUser = ptr("cdfidm")
		smaxJsonOutput.Database.Param.DbPassword = ptr("postgres_pass@FIPS")
		smaxJsonOutput.Database.Param.DbAutoCreate = ptr(false)
		smaxJsonOutput.Database.Param.HighAvailability = nil
	} else {
		smaxJsonOutput.Database.Type = "intpostgres"
		smaxJsonOutput.Database.Param.HighAvailability = ptr(false)
		smaxJsonOutput.Database.Param.DbHost = nil
		smaxJsonOutput.Database.Param.DbPort = nil
		smaxJsonOutput.Database.Param.DbName = nil
		smaxJsonOutput.Database.Param.DbUser = nil
		smaxJsonOutput.Database.Param.DbPassword = nil
		smaxJsonOutput.Database.Param.DbAutoCreate = nil
	}

	// update the major version info.
	if strings.TrimSpace(majorVersion) != "" {
		smaxJsonOutput.Capabilities.Version = strings.TrimSpace(majorVersion)
	} else {
		smaxJsonOutput.Capabilities.Version = strings.Split(smaxVersion, "-")[0]
	}

	// For capabilities, we need X at least.
	capabilitiesList := uniqueAppend(strings.Fields(capabilities), "X")

	// update the capabilities list.
	for _, i := range capabilitiesList {
		var appendElement struct {
			Name string `json:"name"`
		}
		appendElement.Name = i
		smaxJsonOutput.Capabilities.CapabilitySelection = append(smaxJsonOutput.Capabilities.CapabilitySelection, appendElement)
	}

	// add service list, accroding to the capability list ane services received from the param.
	var servicesList []string
	if strings.TrimSpace(services) != "" {
		for _, i := range strings.Fields(services) {
			appendElement := smaxJsonOutput.Capabilities.Configuration[0].ActivatedServices[0]
			if strings.Contains(i, ":") {
				appendElement.Name = strings.Split(i, ":")[0]
				appendElement.RegistryURL = ""
				appendElement.ControllerImgTag = strings.Split(i, ":")[1]
				servicesList = append(servicesList, strings.Split(i, ":")[0])
			} else {
				appendElement.Name = i
				appendElement.RegistryURL = ""
				appendElement.ControllerImgTag = ""
				servicesList = append(servicesList, i)
			}
			smaxJsonOutput.Capabilities.Configuration[0].ActivatedServices = append(smaxJsonOutput.Capabilities.Configuration[0].ActivatedServices, appendElement)
		}
	}

	var allServiceListFromCapability []string
	for _, i := range uniqueAppend(capabilitiesList, "common") {
		allServiceListFromCapability = append(allServiceListFromCapability, feedbackServicesListAccrodingCapabilities(i)...)
	}

	for _, i := range allServiceListFromCapability {
		added := false
		for _, j := range smaxJsonOutput.Capabilities.Configuration[0].ActivatedServices {
			if j.Name == i {
				added = true
				break
			}
		}
		if !added {
			var appendElement struct {
				Name             string `json:"name"`
				RegistryURL      string `json:"registry_url"`
				ControllerImgTag string `json:"controller_img_tag"`
			}
			appendElement.Name = i
			smaxJsonOutput.Capabilities.Configuration[0].ActivatedServices = append(smaxJsonOutput.Capabilities.Configuration[0].ActivatedServices, appendElement)
			servicesList = uniqueAppend(servicesList, i)
		}
	}

	// update the db configuration, accroding to the requireDBServices.
	// e.g.: json:"db_engine,omitempty" indicates that if the db_engine field is set to its zero value (like nil for pointers, 0 for integers, or an empty string for strings), it will be omitted from the JSON encoding.
	if strings.TrimSpace(dbServer) != "" {
		for i := range smaxJsonOutput.Capabilities.Configuration[0].Database {
			smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbServer = ptr(strings.TrimSpace(dbServer))
			smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbLogin = ptr(dbAdminUsername)
			smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbPassword = ptr(dbAdminPass)
		}

		for _, i := range servicesList {
			if _, ok := requireDBServices[i]; ok {
				appendElement := smaxJsonOutput.Capabilities.Configuration[0].Database[0]
				appendElement.ProductName = ptr(requireDBServices[i])
				appendElement.Internal = ptr(false)
				appendElement.DbEngine = ptr("postgres")
				appendElement.DbServer = ptr(strings.TrimSpace(dbServer))
				appendElement.DbPort = ptr("5432")
				appendElement.DbInst = ptr("")
				appendElement.DbLogin = ptr(dbAdminUsername)
				appendElement.DbPassword = ptr(dbAdminPass)
				appendElement.DbPgSslMode = ptr("verify-ca")
				smaxJsonOutput.Capabilities.Configuration[0].Database = append(smaxJsonOutput.Capabilities.Configuration[0].Database, appendElement)
			}
		}

		for i := range smaxJsonOutput.Capabilities.Configuration[0].Database {
			if dbSslCert != "" {
				smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbPgSslMode = ptr("verify-ca")
				smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbSsl = ptr(true)
				smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbSslCertPath = ptr("/app/dbssl/ssl01/root.crt")
				smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbSslCertContent = ptr(dbSslCert)
			} else {
				smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbSsl = ptr(false)
				smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbSslCertPath = nil
				smaxJsonOutput.Capabilities.Configuration[0].Database[i].DbSslCertContent = nil
			}
		}
	} else {
		smaxJsonOutput.Capabilities.Configuration[0].Database = []struct {
			ProductName      *string `json:"product_name,omitempty"`
			Internal         *bool   `json:"internal,omitempty"`
			DbEngine         *string `json:"db_engine,omitempty"`
			DbServer         *string `json:"db_server,omitempty"`
			DbPort           *string `json:"db_port,omitempty"`
			DbInst           *string `json:"db_inst,omitempty"`
			DbLogin          *string `json:"db_login,omitempty"`
			DbPassword       *string `json:"db_password,omitempty"`
			DbSsl            *bool   `json:"db_ssl,omitempty"`
			DbPgSslMode      *string `json:"db_pg_ssl_mode,omitempty"`
			DbSslCertPath    *string `json:"db_ssl_cert_path,omitempty"`
			DbSslCertContent *string `json:"db_ssl_cert_content,omitempty"`
		}{}
	}

	// update the vertica db configuration.
	smaxJsonOutput.Capabilities.Configuration[0].VerticaDatabase[0].DbLogin = ptr(verticaAdminUsername)
	smaxJsonOutput.Capabilities.Configuration[0].VerticaDatabase[0].DbPassword = ptr(verticaAdminPass)
	smaxJsonOutput.Capabilities.Configuration[0].VerticaDatabase[0].DbServer = ptr(verticaServer)
	if verticaServer != "" && verticaSslCert != "" {
		smaxJsonOutput.Capabilities.Configuration[0].VerticaDatabase[0].DbSslCertContent = ptr(verticaSslCert)
	} else if verticaServer != "" && verticaSslCert == "" {
		smaxJsonOutput.Capabilities.Configuration[0].VerticaDatabase[0].DbSsl = ptr(false)
		smaxJsonOutput.Capabilities.Configuration[0].VerticaDatabase[0].DbSslCertContent = nil
		smaxJsonOutput.Capabilities.Configuration[0].VerticaDatabase[0].DbSslCertPath = nil
	} else {
		smaxJsonOutput.Capabilities.Configuration[0].VerticaDatabase = []struct {
			ProductName      *string `json:"product_name,omitempty"`
			DbEngine         *string `json:"db_engine,omitempty"`
			DbServer         *string `json:"db_server,omitempty"`
			DbPort           *string `json:"db_port,omitempty"`
			DbInst           *string `json:"db_inst,omitempty"`
			DbLogin          *string `json:"db_login,omitempty"`
			DbPassword       *string `json:"db_password,omitempty"`
			DbSsl            *bool   `json:"db_ssl,omitempty"`
			DbSslCertPath    *string `json:"db_ssl_cert_path,omitempty"`
			DbSslCertContent *string `json:"db_ssl_cert_content,omitempty"`
		}{}
	}

	// Create a buffer to store the encoded JSON data
	// use this way to make sure & is & not \u0026
	var buf bytes.Buffer
	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false) // Prevent escaping of HTML characters
	if err := encoder.Encode(smaxJsonOutput); err != nil {
		log.Fatal("[FATAL] Error encoding smaxJsonOutput to JSON:", err)
		return
	}

	// Use os.WriteFile to write the data from the buffer to the file
	err = os.WriteFile(baseDir+"/config.json", buf.Bytes(), 0666)
	if err != nil {
		log.Fatal("[FATAL] Error writing smaxJsonOutput to file:", err)
		return
	}

	log.Printf("Data smaxJsonOutput written to %s", baseDir+"/config.json")
}

// Executes the silent installation process.
func executeSilentInstall() {
	var args []string
	baseArgs := []string{
		fmt.Sprintf("%s/ITOM_Platform_Foundation_Standard/install", baseDir),
		"-m", fmt.Sprintf("%s/metadata.tgz", baseDir),
		"-c", fmt.Sprintf("%s/config.json", baseDir),
		"-P", cdfPass,
		"-D", fmt.Sprintf("itom-docker.%s.swinfra.net:443", artifactoryBase),
		"--registry-orgname", "hpeswitomsandbox",
		"-e", "suite",
		"--skip-warning",
		"--nfs-server", nfsServer,
		"--nfs-folder", "/var/vols/itom/core",
		"--timeout", "150",
	}

	if dbServer != "" {
		dbArgs := []string{
			"--db-user", cdfapiServerDbUser,
			"--db-password", cdfapiServerDbPassword,
			"--db-url", fmt.Sprintf("jdbc:postgresql://%s:5432/cdfapiserverdb", dbServer),
		}
		args = append(baseArgs, dbArgs...)
	} else {
		args = baseArgs
	}

	log.Println("Start to exec silent install, it will take some time (about 100+ mins), please kindly be patient ~")
	log.Println("Executing command with arguments: ", args)
	cmd := exec.Command(args[0], args[1:]...)

	if err := cmd.Run(); err != nil {
		log.Fatal("[FATAL] Failed to exec silent install: ", err)
	}

	log.Println("^_^ Silent install has been successfully completed ~")

	// remove "kubectl completion bash" from /etc/bashrc
	removeCmd := "sed -i '/kubectl completion bash/d' /etc/bashrc"
	if err := exec.Command("bash", "-c", removeCmd).Run(); err != nil {
		log.Fatal("[FATAL] Failed to execute sed command: ", err)
	}

	// Add "source <(kubectl completion bash)" to /etc/bashrc
	appendCmd := "echo \"source <(kubectl completion bash)\" >> /etc/bashrc"
	if err := exec.Command("bash", "-c", appendCmd).Run(); err != nil {
		log.Fatal("[FATAL] Failed to append to /etc/bashrc: ", err)
	}
}

// Checks and validates the parameters provided by the user.
func checkParameters() error {
	if strings.TrimSpace(virtualFqdn) == "" {
		masterFqdns := strings.Fields(masters) // split masters to a multiple FQDN map.
		if len(masterFqdns) > 1 {
			log.Fatal("[FATAL] When virtualFqdn is not set, param masters can only have one FQDN.")
		}
	}

	if strings.TrimSpace(dbServer) == "" && !approveAll {
		confirmMsg("Your db-server param is null, please confirm if you want to use internal db?")
	}

	if strings.TrimSpace(nfsServer) == "" && len(strings.Fields(masters)) > 1 {
		log.Fatal("[FATAL] Please input your nfs server hostname by using --nfs-server param.")
	} else if strings.TrimSpace(nfsServer) == "" && !approveAll && len(strings.Fields(masters)) == 1 {
		confirmMsg("Do you want to make your master as nfs server? If you have created the require dir and deployed nfs-server on you master node?")
		nfsServer = masters
	} else if strings.TrimSpace(nfsServer) == "" {
		log.Fatal("[FATAL] Please make sure you have inputed your master nodes by using --masters param.")
	}

	if strings.TrimSpace(workers) == "" {
		log.Fatal("[FATAL] Please make sure you have inputed your worker nodes by using --workers param.")
	}

	currentNodeinMastersList := false
	currentNodeFqdn, _ := os.Hostname()
	for _, i := range strings.Fields(masters) {
		if strings.Contains(i, currentNodeFqdn) {
			currentNodeinMastersList = true
			currentMaster = i
			break
		}
	}
	if !currentNodeinMastersList {
		log.Fatal("[FATAL] This tool is suppose to run on your master node, please check if your param --masters contains current node.")
	}
	if !strings.Contains(smaxVersion, "-") && strings.TrimSpace(majorVersion) == "" {
		log.Fatal("[FATAL] Please input major version by using --major-version param.")
	}

	if dbSslCert == "" && dbServer != "" && !approveAll {
		confirmMsg("You haven't inputted a db certificate, do you want to use a non-ssl db module to connect db?")
	}

	if (strings.Contains(capabilities, "CGRO") || strings.Contains(services, "cgro")) && verticaServer == "" {
		log.Fatal("[FATAL] CGRO is contained in services or capabilities list, please provide vertica hostname.")
	}

	if verticaSslCert == "" && verticaServer != "" && !approveAll {
		confirmMsg("You haven't inputted a vertica certificate, do you want to use a non-ssl db module to connect vertica?")
	}

	return nil
}

// Feedback on the services list based on the capabilities provided.
func feedbackServicesListAccrodingCapabilities(capability string) []string {
	for _, i := range featuresetsJson {
		if i.ID == capability {
			return i.ItsmaServices
		}
	}
	return nil
}

// Makes a call to the given URL with the specified method and data.
func call() {
	getCurrentUser()
	checkParameters()
	createAdminDir()
	downloadAndUnarchiveCdfPkg()
	downloadMetadata()
	updateInstallProperties()
	loadFeaturesetsJsonFromMetadata()
	generateSmaxConfigJson()
	executeSilentInstall()
}

// Lists the embedded resources for the application.
func listEmbedResources() {
	fmt.Println("================ config.json")
	fmt.Println(smaxJson)
	fmt.Println("================ install.properties")
	fmt.Println(installProperties)
}

func init() {
	SilentInstallCmd.Flags().StringVarP(&smaxVersion, "smax-version", "t", "", "Please smax version(metadata tag) here.")
	SilentInstallCmd.Flags().StringVarP(&majorVersion, "major-version", "v", "", "Please smax major version(like 23.4) here.")
	SilentInstallCmd.Flags().StringVarP(&cdfPass, "cdf-pass", "p", "Admin_1234", "Assign a password to cdf portal.")
	SilentInstallCmd.Flags().StringVarP(&cdfVersion, "cdf-version", "", "", "CDF version, like 23.4-144")
	SilentInstallCmd.Flags().StringVarP(&workers, "workers", "n", "", "Give the list of your node group like -n 'node1.example.com node2.example.com'.")
	SilentInstallCmd.Flags().StringVarP(&masters, "masters", "m", "", "Give the list of your master group like -n 'master1.example.com master2.example.com'.")
	SilentInstallCmd.Flags().StringVarP(&nodeRootPass, "node-root-password", "", "iso*help", "Root password of your node.")
	SilentInstallCmd.Flags().StringVarP(&virtualFqdn, "virtual-fqdn", "", "", "Give your virtual fqdn here, if you have multiple masters.")
	SilentInstallCmd.Flags().StringVarP(&artifactoryBase, "artifactoryBase", "a", "orgartifactory", "Give your artifactory base here.")
	SilentInstallCmd.Flags().StringVarP(&nfsServer, "nfs-server", "", "", "NFS hostname.")
	SilentInstallCmd.Flags().StringVarP(&dbServer, "db-server", "", "", "DB hostname.")
	SilentInstallCmd.Flags().StringVarP(&dbAdminUsername, "db-admin", "", "postgres", "DB admin username.")
	SilentInstallCmd.Flags().StringVarP(&dbAdminPass, "db-admin-pass", "", "postgres_pass@FIPS", "DB admin password.")
	SilentInstallCmd.Flags().StringVarP(&dbSslCert, "db-ssl-cert", "", "", "DB ssl certificate.")
	SilentInstallCmd.Flags().StringVarP(&verticaServer, "vertica-server", "", "", "vertica hostname.")
	SilentInstallCmd.Flags().StringVarP(&verticaAdminUsername, "vertica-admin", "", "cgrodba", "vertica admin username.")
	SilentInstallCmd.Flags().StringVarP(&verticaAdminPass, "vertica-admin-pass", "", "Cloud_123", "vertica admin password.")
	SilentInstallCmd.Flags().StringVarP(&verticaSslCert, "vertica-ssl-cert", "", "", "vertica ssl certificate.")
	SilentInstallCmd.Flags().StringVarP(&cdfapiServerDbUser, "cdfapi-server-db-user", "", "cdfapiserver", "DB username for cdf")
	SilentInstallCmd.Flags().StringVarP(&cdfapiServerDbPassword, "cdfapi-server-db-pass", "", "postgres_pass@FIPS", "DB password for cdf db")
	SilentInstallCmd.Flags().StringVarP(&capabilities, "capabilities", "", "", "The list of SMAX capabilities you want to enable except X and common. e.g.: 'DND CGRO SMPS SAM'")
	SilentInstallCmd.Flags().StringVarP(&services, "services", "", "", "Additional services you want to enable of you want to specify tags. e.g. 'itom-chat itom-sm-gateway:tag'")
	SilentInstallCmd.Flags().BoolVar(&masterAsWorker, "master-as-worker", false, "If to make master as a worker.")
	SilentInstallCmd.Flags().BoolVar(&listResources, "list-resources", false, "List embedded resources.")
	SilentInstallCmd.Flags().BoolVar(&approveAll, "auto-approve", false, "Auto approve all the choice.")
	SilentInstallCmd.Flags().BoolVar(&enableVxlan, "enable-vxlan", false, "Auto approve all the choice.")
}
